

//http://www.gotdotnet.ru/blogs/bezzus/1211/
//http://martinfowler.com/articles/injection.html
//
// IoC
// "не зови меня, я сам тебя вызову"

namespace DP_Architect_InversionOfControl
{
// зависимость "has a", класс Foo зависит от класса Bar (явно создает экземпляр этого класса)
// и не может быть использован без него.
//
/*public class Bar...;

public class Foo
{
private Bar _bar = new Bar();

// используем "_bar"
// ...
}
  */

  // Применяем IoC

  // декларируем некий публичный контракт, которому должен удовлетворять Bar;
  //
  public interface IBar
  {
  }

  // теперь Bar обязан реализовать этот контракт
  //
  public class Bar : IBar
  {

  }

  // а класс Foo теперь завязан не на конкретную реализацию Bar, а всего лишь 
  // на задекларированный ранее публичный контракт
  //
  public class Foo
  {
    private IBar _bar;
  
    public Foo(IBar bar)
    {
      _bar = bar;
    }
  }

//1. Повышается тестируемость кода. Теперь классы Foo и Bar можно протестировать 
  //независимо друг от друга и классу Foo, вместо конкретной реализации Bar 
  //подпихнуть какой-нибудь mock объект, реализующий IBar.
//2. При написании распределенного приложения, если реализацию Foo 
  //хочется использовать и на сервере и на клиенте, нет необходимости тащить 
  //на клиента ту же самую реализацию Bar (и последующие зависимости, буде 
  //таковые случатся). Достаточно реализовать специфичную для клиента версию 
  //контракта IBar.
//3. В том случае, когда класс Foo напрямую зависит от класса Bar существует 
  //большая опасность завязаться на особенности конкретной реализации класса Bar 
  //не задекларированные явно в публичном контракте (нарушить LSP). Таким образом, 
  //изменения в реализации Bar могут отразится и на Foo, и вызвать в нем так же ряд 
  //изменений. 


  class Program
  {
    static void Main(string[] args)
    {

    }
  }
}
